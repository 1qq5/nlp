# 本节课笔记目录

- [理论学习](/02_1.md)
- [波士顿地铁路线规划](/02_2.md)
- [作业：北京地铁路线规划](/02_3.md)
- 作业：寻找最佳预测拟合模型（本文）

4. Mathematical or Analytical Based 基于数学或统计的模型

# 作业：寻找最佳预测拟合模型

很多机器学习的优化是通过数学运算完成的。比如我们希望能够找到最佳的线性回归。为了简化问题，这里我们以 `sklearn` 中的波士顿房价数据集中的 `RM` 变量与最终房价之间的关系为例。
```python
%matplotlib inline

from sklearn.datasets import load_boston
import matplotlib.pyplot as plt
import pandas as pd
import random

data = load_boston()
df = pd.DataFrame(data['data'], columns=data['feature_names'])
y = data['target']
X = df.RM # I choose RM column
```
如果我们画散点图，可以看到大概的线性拟合。

![](/pics/plot.png)

下面我们随机画一条直线，看看拟合情况：

![](/pics/plot_2.png)

拟合有够烂。假如我们画足够多条线，那么很可能会有一条线能够较好地拟合数据。这就是第一种算法：随机选择斜率和截距。首先我们需要一个定义：损失函数，它是一种衡量模型性能的量度，一般使用均方差或平均绝对值之差（进行平方或绝对值转换是为了消除差的正负性）。
```python
def RMSE(y, y_hat):
    return np.sqrt(sum((y - y_hat) ** 2) / len(y)) # 定义 RMSE

def MAE(y, y_hat):
    return sum(abs(y - y_hat)) / len(y) # 定义 MAE

def loss_random(X, y, n, loss=RMSE):
    loss_min = float('inf')
    k_best, b_best = 0, 0
    for i in range(n):
        k = random.random() * 200 - 100
        b = random.random() * 200 - 100
        y_hat = k * X + b
        loss_new = loss(y, y_hat)
        if loss_new < loss_min:
            loss_min = loss_new
            k_best, b_best = k, b
            print(f"round: {i}, k: {k_best}, b: {b_best}, {loss}: {loss_min}")
        
    return (k_best, b_best)
```
我们来运行一下。
```python
>>> loss_random(X, y, 2000, RMSE)
round: 0, k: 4.402874158246391, b: 43.9869794773561, <function RMSE at 0x1a227b3378>: 49.6760472638054
round: 9, k: -6.164610809021909, b: 63.35799023513985, <function RMSE at 0x1a227b3378>: 12.758239429343842
round: 21, k: 7.399690002005215, b: -33.443699875605844, <function RMSE at 0x1a227b3378>: 11.608200130639993
round: 120, k: 15.726685151188917, b: -76.57825590792893, <function RMSE at 0x1a227b3378>: 8.080710915756143
round: 1007, k: 7.305008403497709, b: -19.71394884241468, <function RMSE at 0x1a227b3378>: 7.655457643047357
(7.305008403497709, -19.71394884241468)
```
因为斜率和截距是随机选择的，具有相当大的偶然性。